---
title: "Hobbism Issues & Solutions"
date: "2025-10-11"
tags: [Project]
image: "/thumbnails/project.jpeg"
---

## Hobbism project 진행 중 발생한 이슈 및 트러블 슈팅 정리

- 프로젝트 기간 : 2025.07.07 ~ 2025.08.07

### 주요 이슈 사항 정리

| 날짜  | 이슈 요약                            | 상세 내용                                                                                                                  | 해결 여부 |
| ----- | ------------------------------------ | -------------------------------------------------------------------------------------------------------------------------- | --------- |
| 07-15 | 회원가입 시 409 에러                 | 기존 가입자가 로그인 버튼 클릭 시 409 에러 발생회원가입 후 자동 로그인 기능 구현으로 302 리다이렉트 처리                   | 해결      |
| 07-22 | 소셜 로그인 유저 데이터 누락         | 소셜 로그인 시 주소, 전화번호를 기본값 설정 후 Zustand Store에서 관리 (전화번호는 형식에 맞지 않으면 에러 발생)            | 해결      |
| 07-25 | API 폴더 충돌로 인한 로그인 404 에러 | api/auth/[...nextauth] 경로와 루트 api 폴더 충돌로 배포 환경에서 404 에러가 발생하여 폴더 분리로 해결                      | 해결      |
| 08-04 | 오늘 하루 보지 않기 만료 처리 기능   | localStorage의 key중 만료 시간이 지난 항목들이 누적되는 현상이 발생 페이지 진입 시 불필요한 키를 자동 제거하는 함수를 구현 | 해결      |
| 08-06 | 미들웨어 미작동                      | 프로젝트 루트에 있던 미들웨어 파일을 src 하위로 이동 후 콘솔로 동작 확인 후 반영                                           | 해결      |

---

### 트러블슈팅 1: 회원가입 시 409 에러

문제 요약

- 이미 가입된 사용자가 로그인 시도할 경우 **/signup/oauth** API에서 **409 Conflict** 응답 발생

원인 분석

- 중복 회원가입 요청 → 서버에서 에러 응답
- 클라이언트에선 예외처리 없이 중단되어 로그인 실패로 이어짐

해결 방법

- **409** 응답도 **회원가입 완료로 간주**, 로그인 API 요청을 이어서 수행

```tsx
if (signupRes.ok || signupRes.status === 409) {
  // 회원가입 후 자동 로그인 시도
}
```

---

### 트러블슈팅 2: 배포 시 API 폴더 충돌로 인한 로그인 404 에러

문제 요약

- `api/auth/[...nextauth]`에 NextAuth 설정을 작성했지만, 프로젝트 루트에 존재하던 다른 **api/** 폴더와 충돌 발생

원인 분석

- Next.js의 파일 기반 라우팅 시스템에서 동일 라우트(**api/**)가 중복되어 우선순위 문제 발생
  → 배포 환경에서 **/api/auth** 요청 시 404 에러 발생

해결 방법

- 루트의 **api** 폴더를 분리 관리 하여 라우팅 충돌 방지

---

### 핵심 기술: Next.js Middleware + NextAuth JWT 토큰 인증

- `getToken()`을 통해 토큰 가져오기 → **accessToken** 유효성 검증 → 만료 시 **refreshToken**으로 갱신 → 인증 유지
- 실패 시 **/login** 페이지로 리다이렉트
- **matcher**를 통해 인증이 필요한 경로만 미들웨어 작동

[참고한 블로그](https://velog.io/@pds0309/nextjs-%EB%AF%B8%EB%93%A4%EC%9B%A8%EC%96%B4%EB%9E%80)

---

### 트러블슈팅 3: 미들웨어 미작동

문제 요약

- 미들웨어가 전혀 실행되지 않음 → 로그인하지 않아도 보호된 페이지 접근 가능

원인 분석

- **middleware.ts** 파일이 프로젝트 루트에 위치하여 Next.js가 인식하지 못함

해결 방법

- 미들웨어 파일을 **src/middleware.ts**로 이동하여 Next.js가 인식하도록 처리
  → 콘솔로 실행 확인 후 정상 동작

---

## 로그인 구현 시 새롭게 알게된 내용

### 1. 로그인 페이지 배포 시 가능하게 하려면?

각 로그인할 sns에 있는 redirect-uri 변경

### 2. 배포 시 URL 변경

배포 시 각 sns api URL 로컬주소에서 배포주소로 변경

키 값은 vercel 환경변수에서 세팅

### 3. NEXT_PUBLIC 유무 차이

```tsx
NEXT_PUBLIC_API_URP=client → component에서도 사용 가능 (보안 문제로 비추)

API_URP= server component에서만 사용 가능
```

---

## Zustand와 NextAuth를 이용한 토큰 관리 및 미들웨어 적용 과정

### zustand store를 생성하여 토큰 정보 상태관리

- **accessToken**은 **localstorage**, **refreshToken**은 **httpOnly** 쿠키에 저장 (application → cookies → [localhost:3000](http://localhost:3000) 선택하면 보임)

### 로그인 기능 수정 사항 정리

- zustand store 생성하여 **refreshToken**은 **HttpOnly** 쿠키에 나머지는 로컬스토리지에 저장하여 관리함

- middleware를 생성
  1. 엑세스 토큰 검증
  2. 리프레시 토큰으로 엑세스 토큰 재발급
  3. 업데이트 된 엑세스 토큰을 JWT 토큰에 업데이트
  4. 비로그인자 접근 차단
- **TokenSync**라는 컴포넌트를 생성하여 zustand와 NextAuth 간의 자동 업데이트 관리 → layout.tsx에 `<TokenSync>`로 감싸주고 page.tsx에서 `useAuthStore()`로 손쉽게 사용 가능

### **1. Zustand Store (auth.store.ts)**

- AccessToken & 사용자 정보: **localStorage**에 저장
- RefreshToken: **HttpOnly** 쿠키에만 저장 (보안 이슈)
- 상태 관리: **setAccessToken**, **setUser**, **setLoginType**, **clearAuth**

### 2. **Middleware (middleware.ts)**

- 액세스 토큰 검증 (API 서버와 통신)
- 리프레시 토큰으로 액세스 토큰 재발급
- 재발급 받은 액세토큰을 NextAuth JWT에 저장
- 비로그인자 보호된 경로 접근 차단

### 3. **NextAuth 설정 (route.ts)**

- RefreshToken은 HttpOnly 쿠키로 관리

### **4. TokenSync 컴포넌트**

- NextAuth 세션↔ Zustand 자동 동기화
- Layout.tsx에 `<TokenSync />`로 추가
- 모든 페이지에서 `useAuthStore()`로 손쉽게 사용 가능

```tsx
"use client";

import { useAuthStore } from "@/store/auth.store";
import { signOut } from "next-auth/react";

export default function Home() {
  const { user, loginType, accessToken } = useAuthStore();

  const handleLogout = () => {
    signOut({ callbackUrl: "/login" });
  };

  return (
    <div className="flex flex-col items-center justify-center min-h-screen gap-4">
      <div className="text-center">
        <h1 className="text-2xl font-bold mb-4">로그인 성공!</h1>
        <p>안녕하세요, {user?.name}님!</p>
        <p>로그인한 sns : {loginType}</p>
        <p>이메일: {user?.email}</p>
        <p>엑세스 토큰: {accessToken}</p>
      </div>
      <button
        onClick={handleLogout}
        className="px-6 py-2 bg-red-500 text-white rounded-lg hover:bg-red-600"
      >
        로그아웃
      </button>
    </div>
  );
}
```

---

### 요약

- **middleware**는 단순한 함수가 아니라, 요청(Request)을 통제하고 인증 흐름을 제어하는 핵심 역할임
- **zustand**는 **React Context** 보다 가볍고, **SSR** 환경에서도 유연하게 상태를 공유할 수 있음
- **HttpOnly** 쿠키는 브라우저 JS 접근 불가 → 보안상 **RefreshToken**에 적합
