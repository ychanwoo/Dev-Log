---
title: "렌더링 정리"
date: "2025-10-18"
tags: ["Next.js"]
image: "/thumbnails/rendering.jpg"
---

## 렌더링

- 리액트 컴포넌트를 호출해서 HTML 코드를 만드는 작업
- 컴포넌트가 렌더링 되는 위치에 따라 클라이언트 컴포넌트와 서버 컴포넌트로 분류됨
- React는 기본적으로 클라이언트 사이드 렌더링(`CSR`)을 기반으로 하며, Next.js는 서버 사이드 렌더링
  (`SSR`)과 클라이언트 사이드 렌더링(`CSR`)을 모두 활용하는 프레임워크임

### 클라이언트 컴포넌트

- 웹 브라우저가 요청 헤더와 바디를 만들어 서버에 `HTTP` 요청을 보냄
- 서버에서 먼저 실행된 후 결과와 컴포넌트(HTML) 자체를 클라이언트로 전송하는데
  이때 클라이언트에서도 실행되는 컴포넌트로, 브라우저

### 서버 컴포넌트

- 클라이언트의 요청 헤더와 바디를 꺼내어 분석하여 요청을 처리한 결과를 응답 헤더와 바디에 포함해서
  클라이언트에 보냄
- Next.js의 app 라우터를 사용하면 모든 컴포넌트는 기본적으로 서버 컴포넌트가 됨

## 렌더링 방식

| React             | Next.ts                              |
| ----------------- | ------------------------------------ |
| 라이브러리 (UI만) | 프레임워크 (라우팅, SSR, 데이터패칭) |
| CSR               | CSR + SSR + RSC + ISR 모두 가능      |

### CSR (Client Side Redering)

- 브라우저가 모든 렌더링을 담당
- HTML 뼈대만 받고, JS로 실제 콘텐츠 렌더링
- 최초 로딩은 느리지만 이후엔 빠르며, SPA (Single Page Application) 구조에서 많이 사용됨

```bash
브라우저 -> HTML 템플릿 + JS -> 브라우저가 JS 실행 -> 콘텐츠 표시
```

### SSR (Server Side Redering)

- 서버가 HTML을 렌더링(생성)해서 클라이언트에 전달(브라우저에 응답)
- 초기 로딩이 빠르고, 페이지 요청 시마다 서버에 데이터를 요청하고, 새로운 HTML을 생성하여 전달함

```bash
브라우저 -> 서버 요청 -> 서버가 HTML 생성 -> 브라우저에 전달
```

**하이드레이션**

- `SSR`은 서버가 HTML을 생성하여 클라이언트에 전달하여 보여주지만 HTML만으로 페이지가 동작하지 않아 브라우저는 `React`의 `js`파일을 불러와 렌더링된 HTML 파일과 연결해줘야 됨
  이러한 작업을 **하이드레이션** 이라고 함

**하이드레이션 흐름**

```tsx
1 서버: 완성된 HTML 생성
2 클라이언트: HTML 받음 (초기 로딩 빠름)
3 클라이언트: React JS 코드 다운로드
4 클라이언트: HTML과 React 코드 연결(하이드레이션) // 이제 버튼, 상태 변화 등 동작 가능
// 하이드레이션이 끝나면 리액트 앱으로 동작 (CSR)
```

**SSR vs RSC**

- `SSR`은 페이지 단위로 렌더링되며, 서버에서 데이터를 받아 HTML을 생성함 (클라이언트 JS 필요)
- `RSC`(React Server Component)는 컴포넌트 단위로 렌더링되며, 서버에서 데이터를 받아와 컴포넌트 단위로 처리 (HTML만 렌더링) 하고, `use client`를 명시해야 함

**Next.js에서의 RSC 장점**

- 백엔드 데이터 리소스(`DB`등)에 접근 가능
- 클라이언트에서 데이터 요청을 여러번 하지 않고 한번의 요청으로 가져올 수 있음
- 서버에서만 실행되기 때문에 클라이언트로 JS 코드를 전송할 필요가 없음
- FCP가 단축됨

---

### FCP (First Contentful Paint)

- 페이지 로딩이 시작된 후 첫 번째 컨텐츠가 화면에 그려지는 시점을 측정하는 지표로
  처음 렌더링 되는 시점이 빠를수록 사용자 체감 속도가 향상됨
- `Lighthouse`, `WebPageTest`, `Chrome DevTools`등에서 확인할 수 있음

---

### ISR

- Imcremental Static Regneration의 약어로 **정적페이지**를 대상으로 렌더링 하고, 일정 시간이 지나면
  다시 서버에서 리렌더링 됨 → `revalidate` 옵션 사용
- ex) 상품 재고, 가격 가끔씩 업데이트 / 게시물 댓글, 조회수 업데이트

**동작 흐름**

```tsx
1. 최초 요청 시, 정적으로 생성된 HTML을 빠르게 제공함
2. 일정 시간이 지나면, 다음 요청 시 서버가 페이지를 다시 렌더링함
3. 리빌드 후, 새로운 HTML이 캐시에 저자오디고 이후 요청이 반영됨
```

**Data Cache에서의 revalidate와의 차이점?**

- 둘 다 `revalidate`를 통해서 자동 갱신 타이밍을 설정하며, 캐시도 사용하지만,
  `Data Cache`에서는 데이터의 캐시를 관리하는 것이고, `ISR`에서는 페이지 전체의 캐시를 관리함

```tsx
export async function getStaticProps() {
  return {
    props: { ... },
    revalidate: 60, // 60초마다 페이지 재생성
  }
}
```
